<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Hand Tracking Particles (Mobile Optimized)</title>
    <style>
        /* åŸºç¡€é‡ç½®ä¸ç¦æ­¢è§¦æ‘¸ç¼©æ”¾ */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; touch-action: none; -webkit-user-select: none; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI å®¹å™¨ */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* é€šç”¨æ¯›ç»ç’ƒæ ·å¼ */
        .glass-panel {
            background: rgba(20, 25, 40, 0.65);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            pointer-events: auto;
            color: white;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        /* é¡¶éƒ¨æ  (è®¾ç½®æŒ‰é’® + çŠ¶æ€) */
        #top-bar {
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        #status-box {
            max-width: 70%;
        }
        #status {
            font-size: 14px; font-weight: 600; color: #00ffff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
            margin-bottom: 4px;
        }
        #hint { font-size: 10px; color: #bbb; line-height: 1.3; }

        /* è®¾ç½®æŒ‰é’® */
        #toggle-controls {
            width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            z-index: 20;
        }

        /* ä¾§è¾¹æ§åˆ¶é¢æ¿ (æŠ½å±‰å¼) */
        #controls {
            position: absolute;
            top: 0; right: 0;
            width: 260px; height: 100%;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px);
            padding: 20px;
            box-sizing: border-box;
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; flex-direction: column; gap: 15px;
            pointer-events: auto;
            z-index: 15;
            border-left: 1px solid rgba(255,255,255,0.1);
            overflow-y: auto;
        }
        #controls.visible { transform: translateX(0); }
        
        /* æ§åˆ¶é¢æ¿å†…éƒ¨å…ƒç´  */
        .panel-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        h3 { margin: 0; font-size: 16px; color: #00ffff; letter-spacing: 1px; }
        .close-btn { background: none; border: none; color: #aaa; font-size: 24px; padding: 10px; }

        label { font-size: 12px; display: flex; justify-content: space-between; margin-bottom: 5px; color: #ddd; }
        input[type="range"] { width: 100%; accent-color: #00ffff; height: 4px; margin: 10px 0; }
        input[type="color"] { width: 100%; border: none; height: 35px; border-radius: 8px; background: none; }
        
        /* æ¨¡å‹æŒ‰é’®ç½‘æ ¼ */
        .model-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        button.model-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #eee; padding: 12px 5px;
            border-radius: 8px; font-size: 12px;
            transition: 0.2s;
        }
        button.model-btn.active { background: rgba(0, 255, 255, 0.25); border-color: #00ffff; color: white; }

        /* åº•éƒ¨åŒºåŸŸ */
        #bottom-area {
            padding: 20px;
            display: flex; align-items: flex-end; justify-content: space-between;
        }

        /* æ‘„åƒå¤´ç”»ä¸­ç”» */
        #camera-container {
            width: 100px; height: 133px; /* 3:4 ratio for portrait input */
            overflow: hidden;
            position: relative;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            transition: opacity 0.3s;
        }
        #camera-container.hidden { opacity: 0; pointer-events: none; }
        #input-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* å…¨å±æŒ‰é’® */
        #fullscreen-btn {
            width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer;
        }

        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 3px solid rgba(0,255,255,0.3);
            border-top: 3px solid #00ffff; border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div class="spinner"></div>
        <div style="font-size: 14px; margin-top: 15px; color: #888;">æ­£åœ¨åˆå§‹åŒ–å¼•æ“...</div>
        <div style="font-size: 12px; margin-top: 5px; color: #555;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <!-- UI Overlay -->
    <div id="ui-container">
        
        <div id="top-bar">
            <div id="status-box">
                <div id="status">ç­‰å¾…ä¿¡å·...</div>
                <div id="hint">äº¤äº’: å¼ æ‰‹(å‘¼å¸) / ç§»åŠ¨(æ—‹è½¬) / æåˆ(åˆ‡æ¢)</div>
            </div>
            <button id="toggle-controls">âš™ï¸</button>
        </div>

        <!-- Right Drawer Controls -->
        <div id="controls">
            <div class="panel-header">
                <h3>ç²’å­æ§åˆ¶å°</h3>
                <button class="close-btn" id="close-controls">Ã—</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label>æ¨¡å‹åˆ‡æ¢</label>
                <div class="model-grid">
                    <button class="model-btn active" data-type="nebula">ğŸŒŒ æ˜Ÿäº‘</button>
                    <button class="model-btn" data-type="fireworks">ğŸ† çƒŸèŠ±</button>
                    <button class="model-btn" data-type="saturn">ğŸª åœŸæ˜Ÿ</button>
                    <button class="model-btn" data-type="flower">ğŸŒ¸ è™šç©ºèŠ±</button>
                </div>
            </div>

            <div>
                <label>ç²’å­é¢œè‰²</label>
                <input type="color" id="color-picker" value="#00ffff">
            </div>
            
            <div>
                <label>ç²’å­å¯†åº¦ <span id="density-val">15k</span></label>
                <input type="range" id="density-slider" min="5000" max="30000" step="1000" value="15000">
            </div>

            <div>
                <label>ç”»ä¸­ç”»å¼€å…³</label>
                <div style="display:flex; gap:10px; margin-top:5px;">
                    <button class="model-btn" style="flex:1" onclick="document.getElementById('camera-container').classList.toggle('hidden')">æ˜¾ç¤º/éšè—</button>
                </div>
            </div>
            
            <div style="margin-top:auto; font-size:10px; color:#666; padding-top:20px;">
                Designed for Mobile & Tablet
            </div>
        </div>

        <div id="bottom-area">
            <div id="camera-container" class="glass-panel">
                <video id="input-video" playsinline muted autoplay></video>
            </div>
            <div id="fullscreen-btn" class="glass-panel">â›¶</div>
        </div>
    </div>

    <!-- Three.js Logic -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- Detection & Config ---
        const isMobile = window.innerWidth < 768;

        const CONFIG = {
            particleCount: isMobile ? 12000 : 20000, // Reduce count on mobile
            baseColor: new THREE.Color(0x00ffff),
            expansion: 1.0,
            targetRotation: { x: 0, y: 0 },
            handDetected: false,
            pinchCooldown: 0
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        // Adjust camera Z based on screen ratio (Portrait needs to be further back)
        camera.position.z = window.innerWidth < window.innerHeight ? 40 : 30;

        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Cap pixel ratio at 2.0 for high-density mobile screens to save battery
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
        document.body.appendChild(renderer.domElement);

        // --- Post Processing (Bloom) Optimized ---
        const renderScene = new RenderPass(scene, camera);
        
        // On mobile, reduce bloom resolution to half for performance
        const bloomRes = new THREE.Vector2(
            window.innerWidth / (isMobile ? 2 : 1), 
            window.innerHeight / (isMobile ? 2 : 1)
        );
        
        const bloomPass = new UnrealBloomPass(bloomRes, 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.3;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Background Stars ---
        const starsGeometry = new THREE.BufferGeometry();
        const starCount = 3000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount * 3; i++) {
            starPos[i] = (Math.random() - 0.5) * 500;
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starsMaterial = new THREE.PointsMaterial({ color: 0x888888, size: 0.8, transparent: true, opacity: 0.5 });
        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);

        // --- Main Particle System ---
        let geometry, material, points;
        let originalPositions = [];
        let currentPositions = []; 

        function initParticles(count) {
            if(points) scene.remove(points);

            geometry = new THREE.BufferGeometry();
            currentPositions = new Float32Array(count * 3);
            originalPositions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                currentPositions[i*3] = (Math.random() - 0.5) * 10;
                currentPositions[i*3+1] = (Math.random() - 0.5) * 10;
                currentPositions[i*3+2] = (Math.random() - 0.5) * 10;
                
                colors[i*3] = Math.random();
                colors[i*3+1] = Math.random();
                colors[i*3+2] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: CONFIG.baseColor },
                    expansion: { value: 1.0 },
                    // Make particles slightly larger on mobile high-DPI screens
                    pointSize: { value: isMobile ? 4.0 : 3.0 } 
                },
                vertexShader: `
                    uniform float time;
                    uniform float expansion;
                    uniform float pointSize;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec3 pos = position * expansion;
                        // Organic noise movement
                        pos.x += sin(time * 2.0 + position.y * 0.5) * 0.1;
                        pos.y += cos(time * 1.5 + position.x * 0.5) * 0.1;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = pointSize * (40.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying vec3 vColor;
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 1.5);
                        gl_FragColor = vec4(color * vColor * 2.0, glow);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
            setShape('nebula');
        }

        // --- Shape Logic ---
        const SHAPES = {
            nebula: (i) => {
                const r = Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
            },
            fireworks: (i) => {
                const r = Math.pow(Math.random(), 1/3) * 15;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
            },
            saturn: (i) => {
                if (Math.random() > 0.7) {
                    const r = Math.random() * 4;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    return [r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi)];
                } else {
                    const r = 6 + Math.random() * 6;
                    const theta = Math.random() * Math.PI * 2;
                    return [r * Math.cos(theta), (Math.random()-0.5) * 0.5, r * Math.sin(theta)];
                }
            },
            flower: (i) => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5 + 3 * Math.sin(5 * u) * Math.sin(5 * v);
                return [r * Math.sin(v) * Math.cos(u), r * Math.sin(v) * Math.sin(u), r * Math.cos(v)];
            }
        };

        function setShape(type) {
            const generator = SHAPES[type] || SHAPES.nebula;
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const [x, y, z] = generator(i);
                originalPositions[i*3] = x;
                originalPositions[i*3+1] = y;
                originalPositions[i*3+2] = z;
            }
            document.querySelectorAll('.model-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.type === type));
        }

        // --- Interaction ---
        function updateParticles(deltaTime) {
            const positions = points.geometry.attributes.position.array;
            const lerpSpeed = 3.0 * deltaTime;
            
            // Morphing
            for (let i = 0; i < CONFIG.particleCount * 3; i++) {
                positions[i] += (originalPositions[i] - positions[i]) * lerpSpeed;
            }
            points.geometry.attributes.position.needsUpdate = true;

            // Rotation
            if (!CONFIG.handDetected) {
                points.rotation.y += 0.1 * deltaTime;
                points.rotation.x *= (1 - deltaTime); // Return to level
            } else {
                points.rotation.x += (CONFIG.targetRotation.x - points.rotation.x) * 5 * deltaTime;
                points.rotation.y += (CONFIG.targetRotation.y - points.rotation.y) * 5 * deltaTime;
            }

            // Expansion & Color
            material.uniforms.expansion.value += (CONFIG.expansion - material.uniforms.expansion.value) * 5 * deltaTime;
            
            const hueShift = (points.rotation.y * 0.02) % 1.0; 
            const hsl = {};
            CONFIG.baseColor.getHSL(hsl);
            material.uniforms.color.value.setHSL((hsl.h + hueShift) % 1.0, hsl.s, hsl.l);
            material.uniforms.time.value += deltaTime;
        }

        // --- MediaPipe ---
        const videoElement = document.getElementById('input-video');
        
        function onResults(results) {
            // Hide Loader
            const loader = document.getElementById('loader');
            if(loader) { loader.style.opacity = 0; setTimeout(() => loader.remove(), 500); }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                CONFIG.handDetected = true;
                document.getElementById('status').innerText = "âœ… ç¥ç»é“¾è·¯å·²è¿æ¥";
                document.getElementById('status').style.color = "#00ff00";

                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Rotation (Middle Finger MCP)
                const x = landmarks[9].x; 
                const y = landmarks[9].y;
                
                // Wider range for mobile sensitivity
                CONFIG.targetRotation.y = (x - 0.5) * Math.PI * 2.5;
                CONFIG.targetRotation.x = (y - 0.5) * Math.PI * 1.5;

                // 2. Expansion (Wrist to Middle Tip)
                const wrist = landmarks[0];
                const tip = landmarks[12];
                const distance = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                
                // Tuned for typical hand distance from phone camera
                const normOpen = Math.min(Math.max((distance - 0.15) * 3.5, 0), 1);
                CONFIG.expansion = 0.5 + (normOpen * 2.0);

                // 3. Pinch (Thumb to Middle)
                const thumb = landmarks[4];
                const pinchDist = Math.sqrt(Math.pow(thumb.x - tip.x, 2) + Math.pow(thumb.y - tip.y, 2));
                
                if (pinchDist < 0.06 && Date.now() > CONFIG.pinchCooldown) {
                    cycleModel();
                    CONFIG.pinchCooldown = Date.now() + 1000;
                    const s = document.getElementById('status');
                    s.innerText = "âœ¨ åˆ‡æ¢æ¨¡å‹";
                    s.style.color = "#fff";
                }

            } else {
                CONFIG.handDetected = false;
                document.getElementById('status').innerText = "ğŸ” æœç´¢æ‰‹éƒ¨ä¿¡å·...";
                document.getElementById('status').style.color = "#00ffff";
                CONFIG.expansion = 1.0;
            }
        }

        function cycleModel() {
            const keys = Object.keys(SHAPES);
            const currentBtn = document.querySelector('.model-btn.active');
            const currentType = currentBtn ? currentBtn.dataset.type : 'nebula';
            const nextIdx = (keys.indexOf(currentType) + 1) % keys.length;
            setShape(keys[nextIdx]);
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1, // 0 for max speed, 1 for balance
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        // Lower camera resolution for mobile performance
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: isMobile ? 320 : 640,
            height: isMobile ? 240 : 480
        });
        
        cameraUtils.start().catch(err => {
            document.getElementById('loader').innerHTML = "<div style='padding:20px; text-align:center'>å¯åŠ¨å¤±è´¥<br>è¯·æ£€æŸ¥æ‘„åƒå¤´æƒé™<br>æˆ–ç¡®ä¿ä½¿ç”¨HTTPS/Localhost</div>";
        });

        // --- Init & Events ---
        initParticles(CONFIG.particleCount);

        // UI Toggles
        const controlsEl = document.getElementById('controls');
        document.getElementById('toggle-controls').addEventListener('click', () => controlsEl.classList.add('visible'));
        document.getElementById('close-controls').addEventListener('click', () => controlsEl.classList.remove('visible'));

        document.getElementById('color-picker').addEventListener('input', (e) => CONFIG.baseColor.set(e.target.value));
        
        document.getElementById('density-slider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('density-val').innerText = (val/1000).toFixed(0) + 'k';
            CONFIG.particleCount = val;
            initParticles(val);
        });

        document.querySelectorAll('.model-btn').forEach(btn => {
            if(!btn.onclick) btn.addEventListener('click', () => setShape(btn.dataset.type));
        });

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        });

        // Resize Logic
        window.addEventListener('resize', () => {
            // Update camera aspect
            camera.aspect = window.innerWidth / window.innerHeight;
            // Adjust Z position for portrait/landscape switch
            camera.position.z = window.innerWidth < window.innerHeight ? 40 : 30;
            camera.updateProjectionMatrix();
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            // Recalculate bloom resolution
            const newIsMobile = window.innerWidth < 768;
            bloomPass.resolution.set(
                window.innerWidth / (newIsMobile ? 2 : 1), 
                window.innerHeight / (newIsMobile ? 2 : 1)
            );
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            updateParticles(delta);
            starField.rotation.y -= 0.05 * delta;
            composer.render();
        }
        animate();

    </script>
</body>
</html>