<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Tracking Particle System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI Container */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Common Glassmorphism Style */
        .glass-panel {
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            pointer-events: auto;
            color: white;
            padding: 15px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }

        /* Right Side Controls */
        #controls {
            position: absolute;
            
            top: 20px;
            right: 20px;
            width: 220px;
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        h3 { margin: 0 0 10px 0; font-size: 16px; color: #00ffff; text-transform: uppercase; letter-spacing: 1px; }
        
        label { font-size: 12px; display: flex; justify-content: space-between; margin-top: 5px; }
        
        input[type="range"] { width: 100%; accent-color: #00ffff; cursor: pointer; }
        input[type="color"] { width: 100%; border: none; height: 30px; cursor: pointer; background: none; }
        
        button.model-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: 0.2s;
            text-align: left;
            font-size: 13px;
        }
        button.model-btn:hover, button.model-btn.active {
            background: rgba(0, 255, 255, 0.2);
            border-color: #00ffff;
        }

        /* Bottom Left Camera PIP */
        #camera-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            overflow: hidden;
            resize: both; /* Resize capability */
            min-width: 100px;
            min-height: 75px;
            max-width: 400px;
        }
        
        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }
        
        .pip-label {
            position: absolute;
            bottom: 5px;
            left: 5px;
            font-size: 10px;
            background: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 4px;
        }

        /* Bottom Right Fullscreen */
        #fullscreen-btn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
        }

        /* Status & Hints */
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 12px;
            color: #00ffff;
            text-shadow: 0 0 5px #00ffff;
        }

        #hint {
            margin-top: 10px;
            font-size: 11px;
            color: #aaa;
            line-height: 1.4;
        }

        /* Loading Overlay */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #00ffff;
            font-size: 20px;
            transition: opacity 0.5s;
        }
    </style>
    
    <!-- MediaPipe Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loader">
        <div>...</div>
        <div style="font-size: 14px; margin-top: 10px; color: #666;">è¯·å…è®¸æ‘„åƒå¤´æƒé™</div>
    </div>

    <!-- UI Overlay -->
    <div id="ui-container">
        <div id="status">ç³»ç»Ÿå¾…æœº - ç­‰å¾…æ‰‹éƒ¨è¯†åˆ«...</div>

        <!-- Controls Sidebar -->
        <div id="controls" class="glass-panel">
            <h3>ç²’å­æ§åˆ¶å°</h3>
            
            <div style="margin-bottom: 15px;">
                <label>æ¨¡å‹é€‰æ‹© (æåˆæ‹‡æŒ‡+ä¸­æŒ‡åˆ‡æ¢)</label>
                <div style="display: flex; flex-direction: column; gap: 5px; margin-top: 5px;">
                    <button class="model-btn active" data-type="nebula">ğŸŒŒ æ˜Ÿäº‘ (Nebula)</button>
                    <button class="model-btn" data-type="fireworks">ğŸ† çƒŸèŠ± (Fireworks)</button>
                    <button class="model-btn" data-type="saturn">ğŸª åœŸæ˜Ÿ (Saturn)</button>
                    <button class="model-btn" data-type="flower">ğŸŒ¸ è™šç©ºèŠ± (Flower)</button>
                </div>
            </div>

            <div>
                <label>åŸºç¡€é¢œè‰² <input type="color" id="color-picker" value="#00ffff"></label>
            </div>
            
            <div>
                <label>ç²’å­å¯†åº¦ <span id="density-val">20k</span></label>
                <input type="range" id="density-slider" min="5000" max="40000" step="1000" value="20000">
            </div>

            <div id="hint">
                äº¤äº’æŒ‡å—:<br>
                âœ‹ å¼ å¼€/æ¡æ‹³: ç²’å­æ‰©æ•£/æ”¶ç¼©<br>
                ğŸ‘‹ ç§»åŠ¨æ‰‹éƒ¨: æ—‹è½¬æ¨¡å‹<br>
                ğŸ‘Œ æ‹‡æŒ‡+ä¸­æŒ‡æåˆ: åˆ‡æ¢æ¨¡å‹
            </div>
        </div>

        <!-- Camera PIP -->
        <div id="camera-container" class="glass-panel">
            <video id="input-video" playsinline></video>
            <div class="pip-label">LIVE FEED</div>
        </div>

        <!-- Fullscreen -->
        <div id="fullscreen-btn" class="glass-panel">
            â›¶
        </div>
    </div>

    <!-- Three.js Logic -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            particleCount: 15000,
            baseColor: new THREE.Color(0x00ffff),
            expansion: 1.0,
            rotationSpeed: 0.0,
            targetRotation: { x: 0, y: 0 },
            currentRotation: { x: 0, y: 0 },
            handDetected: false,
            pinchCooldown: 0
        };

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- Post Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Background Stars ---
        const starsGeometry = new THREE.BufferGeometry();
        const starCount = 5000;
        const starPos = new Float32Array(starCount * 3);
        for(let i=0; i<starCount * 3; i++) {
            starPos[i] = (Math.random() - 0.5) * 400; // Deep space
        }
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, transparent: true, opacity: 0.6 });
        const starField = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(starField);

        // --- Main Particle System ---
        let geometry, material, points;
        let originalPositions = []; // Store target shapes
        let currentPositions = [];  // Current animation state

        function initParticles(count) {
            if(points) scene.remove(points);

            geometry = new THREE.BufferGeometry();
            currentPositions = new Float32Array(count * 3);
            originalPositions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                currentPositions[i*3] = (Math.random() - 0.5) * 10;
                currentPositions[i*3+1] = (Math.random() - 0.5) * 10;
                currentPositions[i*3+2] = (Math.random() - 0.5) * 10;
                
                colors[i*3] = Math.random();
                colors[i*3+1] = Math.random();
                colors[i*3+2] = Math.random();
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Custom Shader Material for performance and control
            material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: CONFIG.baseColor },
                    expansion: { value: 1.0 },
                    pointSize: { value: 3.0 } // Scaled by density later
                },
                vertexShader: `
                    uniform float time;
                    uniform float expansion;
                    uniform float pointSize;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec3 pos = position * expansion;
                        // Add some noise movement
                        pos.x += sin(time * 2.0 + position.y) * 0.1;
                        pos.y += cos(time * 1.5 + position.x) * 0.1;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = pointSize * (30.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    varying vec3 vColor;
                    void main() {
                        // Circle shape
                        float r = distance(gl_PointCoord, vec2(0.5, 0.5));
                        if (r > 0.5) discard;
                        
                        // Glow center
                        float glow = 1.0 - (r * 2.0);
                        glow = pow(glow, 1.5);
                        
                        gl_FragColor = vec4(color * vColor * 2.0, glow);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            points = new THREE.Points(geometry, material);
            scene.add(points);
            
            // Initial shape
            setShape('nebula');
        }

        // --- Shape Generators ---
        const SHAPES = {
            nebula: (i) => {
                const r = Math.random() * 10;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                return [
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                ];
            },
            fireworks: (i) => {
                const r = Math.pow(Math.random(), 1/3) * 15; // Uniform sphere volume
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                return [
                    r * Math.sin(phi) * Math.cos(theta),
                    r * Math.sin(phi) * Math.sin(theta),
                    r * Math.cos(phi)
                ];
            },
            saturn: (i) => {
                // 30% sphere, 70% ring
                if (Math.random() > 0.7) {
                    const r = Math.random() * 4;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    return [
                        r * Math.sin(phi) * Math.cos(theta),
                        r * Math.sin(phi) * Math.sin(theta),
                        r * Math.cos(phi)
                    ];
                } else {
                    const r = 6 + Math.random() * 6;
                    const theta = Math.random() * Math.PI * 2;
                    return [
                        r * Math.cos(theta),
                        (Math.random()-0.5) * 0.5, // Thin disk
                        r * Math.sin(theta)
                    ];
                }
            },
            flower: (i) => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 5 + 3 * Math.sin(5 * u) * Math.sin(5 * v);
                return [
                    r * Math.sin(v) * Math.cos(u),
                    r * Math.sin(v) * Math.sin(u),
                    r * Math.cos(v)
                ];
            }
        };

        function setShape(type) {
            const positions = points.geometry.attributes.position.array;
            const generator = SHAPES[type] || SHAPES.nebula;

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const [x, y, z] = generator(i);
                originalPositions[i*3] = x;
                originalPositions[i*3+1] = y;
                originalPositions[i*3+2] = z;
            }
            // Update UI buttons
            document.querySelectorAll('.model-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.type === type);
            });
        }

        // --- Interaction Logic ---
        function updateParticles(deltaTime) {
            const positions = points.geometry.attributes.position.array;
            
            // 1. Morphing Animation (Lerp to target shape)
            const lerpSpeed = 3.0 * deltaTime;
            for (let i = 0; i < CONFIG.particleCount * 3; i++) {
                positions[i] += (originalPositions[i] - positions[i]) * lerpSpeed;
            }
            points.geometry.attributes.position.needsUpdate = true;

            // 2. Rotation (Controlled by hand + auto idle)
            if (!CONFIG.handDetected) {
                points.rotation.y += 0.1 * deltaTime;
            } else {
                // Smoothly interpolate rotation
                points.rotation.x += (CONFIG.targetRotation.x - points.rotation.x) * 5 * deltaTime;
                points.rotation.y += (CONFIG.targetRotation.y - points.rotation.y) * 5 * deltaTime;
            }

            // 3. Expansion (Controlled by hand open/close)
            // Smooth transition for uniform
            material.uniforms.expansion.value += (CONFIG.expansion - material.uniforms.expansion.value) * 5 * deltaTime;

                       // 4. Color Hue Shift based on rotation (é¢œè‰²éšæ—‹è½¬å˜åŒ–)
            // ä¿®æ”¹è¯´æ˜ï¼šæˆ‘ä»¬å°†æ—‹è½¬è§’åº¦ä¹˜ä»¥ 0.1ï¼Œæ„å‘³ç€æ—‹è½¬é€Ÿåº¦å¯¹é¢œè‰²çš„å½±å“å˜æˆäº†åŸæ¥çš„ 1/10
            // ä½ å¯ä»¥å°† 0.1 æ”¹ä¸ºæ›´å°çš„æ•°å­—ï¼ˆå¦‚ 0.05ï¼‰è®©å®ƒå˜å¾—æ›´æ…¢
            const hueShift = (points.rotation.y * 0.001); 
            
            const hsl = {};
            CONFIG.baseColor.getHSL(hsl);
            
            // ä½¿ç”¨ % 1.0 ç¡®ä¿è‰²ç›¸å€¼å§‹ç»ˆåœ¨ 0~1 ä¹‹é—´å¾ªç¯
            // é€»è¾‘ï¼šåŸºç¡€è‰²ç›¸ + (æ—‹è½¬å¸¦æ¥çš„åç§»)
            material.uniforms.color.value.setHSL((hsl.h + hueShift) % 1.0, hsl.s, hsl.l);
            
            // 5. Time uniform
            material.uniforms.time.value += deltaTime;
        }

        // --- MediaPipe Hands ---
        const videoElement = document.getElementById('input-video');
        
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                document.getElementById('status').innerText = "å·²æ•è·å¤§è‚˜å­";
                document.getElementById('status').style.color = "#00ff00";
                CONFIG.handDetected = true;

                const landmarks = results.multiHandLandmarks[0];
                
                // 1. Position -> Rotation
                // Landmark 9 is Middle Finger MCP (roughly center of palm)
                // Normalize coordinates are 0-1. 0.5 is center.
                // We flip X because video is mirrored usually.
                const x = landmarks[9].x; 
                const y = landmarks[9].y;
                
                // Map x [0,1] to Rotation Y [-PI, PI]
                CONFIG.targetRotation.y = (x - 0.5) * Math.PI * 2;
                // Map y [0,1] to Rotation X [-0.5, 0.5] (Limit vertical rotation)
                CONFIG.targetRotation.x = (y - 0.5) * Math.PI;

                // 2. Openness -> Expansion
                // Calculate distance between Wrist(0) and Middle Finger Tip(12)
                const wrist = landmarks[0];
                const tip = landmarks[12];
                const distance = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                
                // Approximate: Closed fist ~0.1-0.2, Open hand ~0.4-0.5
                // Map to expansion 0.5 to 2.0
                const normOpen = Math.min(Math.max((distance - 0.2) * 4.0, 0), 1); // 0 to 1
                CONFIG.expansion = 0.5 + (normOpen * 2.0);

                // 3. Pinch Detection -> Switch Model
                // Thumb(4) and Middle(12) tips
                const thumb = landmarks[4];
                const middle = landmarks[12];
                const pinchDist = Math.sqrt(Math.pow(thumb.x - middle.x, 2) + Math.pow(thumb.y - middle.y, 2));
                
                // Pinch threshold
                if (pinchDist < 0.05) {
                    if (Date.now() > CONFIG.pinchCooldown) {
                        cycleModel();
                        CONFIG.pinchCooldown = Date.now() + 1000; // 1 sec cooldown
                        
                        // Visual Feedback
                        const status = document.getElementById('status');
                        status.innerText = "æ‰‹åŠ¿æŒ‡ä»¤ï¼šåˆ‡æ¢æ¨¡å‹";
                        status.style.textShadow = "0 0 10px white";
                        setTimeout(() => status.style.textShadow = "0 0 5px #00ffff", 200);
                    }
                }

            } else {
                CONFIG.handDetected = false;
                document.getElementById('status').innerText = "æœç´¢å¤§æ‰‹å­ä¸­...";
                document.getElementById('status').style.color = "#00ffff";
                // Slowly return to idle expansion
                CONFIG.expansion = 1.0;
            }
        }

        const modelKeys = Object.keys(SHAPES);
        function cycleModel() {
            // Find current active
            let currentBtn = document.querySelector('.model-btn.active');
            let currentType = currentBtn ? currentBtn.dataset.type : 'nebula';
            let idx = modelKeys.indexOf(currentType);
            let nextIdx = (idx + 1) % modelKeys.length;
            setShape(modelKeys[nextIdx]);
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        
        // Start camera
        cameraUtils.start()
            .then(() => {
                document.getElementById('loader').style.opacity = 0;
                setTimeout(() => document.getElementById('loader').remove(), 500);
            })
            .catch(err => {
                console.error(err);
                document.getElementById('loader').innerHTML = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥<br>è¯·ç¡®ä¿åœ¨HTTPSæˆ–Localhostç¯å¢ƒä¸‹è¿è¡Œ";
            });

        // --- Initialization ---
        initParticles(CONFIG.particleCount);

        // --- UI Event Listeners ---
        // Color Picker
        document.getElementById('color-picker').addEventListener('input', (e) => {
            CONFIG.baseColor.set(e.target.value);
        });

        // Density Slider
        document.getElementById('density-slider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('density-val').innerText = (val/1000).toFixed(0) + 'k';
            CONFIG.particleCount = val;
            initParticles(val); // Rebuild system
        });

        // Model Buttons
        document.querySelectorAll('.model-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setShape(btn.dataset.type);
            });
        });

        // Fullscreen
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            updateParticles(delta);

            // Subtle rotation for background stars
            starField.rotation.y -= 0.02 * delta;

            composer.render();
        }

        animate();

    </script>
</body>
</html>